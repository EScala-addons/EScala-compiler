\documentclass[article,colorback,accentcolor=tud4c]{tudreport}
\usepackage{ngerman}

\usepackage[stable]{footmisc} 
\usepackage[ngerman]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{pst-all}
\usepackage{amsmath}
\usepackage{subfigure}


% Makros
\newcommand{\before}[1]{\textit{ before(#1) }}
\newcommand{\after}[1]{\textit{after(#1)}}
\newcommand{\aktiv}[1]{\textit{active(#1)}}
\newcommand{\Interval}[1]{\textbf{interval#1}}
\newcommand{\comp}[1]{\textit{#1.complement}}
\newcommand{\val}[1]{\textit{value(#1)}}
\newcommand{\betw}[2]{\textit{between(e#1,e#2)}}

\hypersetup{%
  pdftitle={IntervalEvents in EScala: Design}, pdfauthor={Michael Kutschke und Frank Englert}, pdfsubject={IntervalEvents in EScala: Design}, pdfview=FitH, pdfstartview=FitV }

\setcounter{seclinedepth}{1}

  \newif\ifTUDmargin\TUDmarginfalse \ifTUDmargin\makeatletter
    \TUD@setmarginpar{2}
  \makeatother\fi

\newlength{\longtablewidth}
\setlength{\longtablewidth}{0.7\linewidth}
\addtolength{\longtablewidth}{-\marginparsep}
\addtolength{\longtablewidth}{-\marginparwidth}

\title{IntervalEvents in EScala: Design}
\subtitle{Michael Kutschke und Frank Englert}

\begin{document}

\maketitle

\tableofcontents

\section{Grundlegende Definitionen}
\label{definitions}
Sei \before{\Interval} : Event das Ereignis, das den Beginn des Intervalls int angibt
und \after{\Interval} : Event jenes, welches das Ende des Intervalls angibt.
Ausserdem gebe \aktiv\Interval{} : boolean an, ob das Intervall aktiv ist.
In der jetzigen Fassung bedeutet dies einfach, ob man sich zeitlich innerhalb des
Intervalls befindet. 
Der Wert des Active-Flags hat dabei die in Abb.
\ref{active_bit_behaviour} gezeigte Semantik. Zum Zeitpunkt des
Before-Events ist \aktiv\Interval{} noch nicht gesetzt. Dies ist keine
Einschr"ankung, wie im weiteren gezeigt werden wird. 

\begin{figure}[h]
 \centering 
\psset{unit=1cm} 
\begin{pspicture}(0,0)(10,2)
\psgrid[subgriddiv=1,griddots=10,gridlabels=7pt,](0,0)(10,2)
%{
%	\pspolygon[fillcolor=greenyellow,fillstyle=solid,linestyle=none](0,0)(0,1)(1,1)(1,0)

	\rput(1.2,0.7){\psframebox*[framearc=.3]{B}}
	\rput(9.2,0.7){\psframebox*[framearc=.3]{A}}
	\rput(0.2,1.05){\psframebox*[framearc=.3]{Aktiv}} 
	\psline[linewidth=1pt]{]-]}(1,1)(9,1)
%}
\end{pspicture}
\caption{Wert des Aktiv-Bits}
\label{active_bit_behaviour}
\end{figure}

\betw{1}{2} ist das Intervall, dass beim Auftreten von e1 aktiviert und beim Auftreten von e2 deaktiviert wird. Man
beachte hierbei, dass \before\betw{1}{2} $\neq$  e1 und \after\betw{1}{2} $\neq$ e2.

F"ur alle Intervalle muss gelten, dass active nur beim \before{\_} oder
\after{\_} Event umgeschaltet wird, wobei \aktiv{\_} nur von einem \before{\_}
Event gesetzt und von einem \after{\_} Event zur"uckgesetzt werden kann.
Ausserdem sollten ausserhalb des Intervalls keine isolierten Events auftreten. Dies muss beim Implementierung von Unterklassen von IntervalEvent beachtet werden.

\section{Operatoren}
Im folgenden werden die auf Intervall-Events verfügbaren Operatoren definiert. Hierbei ist jeweils \Interval\ ein Intervall und e ein punktuelles Event. Zu beachten ist, dass \before{\Interval{}} und \after{\Interval{}} ebenfalls punktuell sind und
|| auf punktuellen Events Disjunktion, \&\&\ Konjunktion bzw. Filter nach Prädikaten und \textbackslash\ Differenz bedeutet.

\subsection{Komplement \comp\Interval : Intervall}
\begin{itemize}
\item \before{\comp{\Interval}} <=> \after{\Interval}
\item \after{\comp{\Interval}} <=> \before{\Interval} 
\item \aktiv{\comp{\Interval}} <=> ! \aktiv{\Interval}
\end{itemize}
Bei der Implementierung wird ein neues Intervall-Event erzeugt, bei dem das 
Before-Event mit dem After-Event getauscht ist. Das Komplement bietet keinen
Zugriff auf den Wert des Intervall-Events.

\subsection{Vereinigung \Interval{1} || \Interval{2} : Intervall}
Die Semantik der ||-Vereinigung ist die Vereinigung der Zeitpunkte von
\Interval{1} und \Interval{2}.
\begin{itemize}
\item \before{\Interval{1} || \Interval{2}}  <=> \before{\Interval{1}} || \before{\Interval{2}}
\item \after{\Interval{1} || \Interval{2}} <=> ((\after{\Interval{1}} \&\&
!\aktiv{\Interval{2}}) || (\after{\Interval{2}} \&\& !\aktiv{\Interval{1}}) ||
(\after{\Interval{1}} \&\& \after{\Interval{2}} )) \textbackslash\ (\before{\Interval{1}}|| \before{\Interval{2}})
\item \aktiv{\Interval{1} || \Interval{2}} <=> \aktiv{Interval{1}} || \aktiv{\Interval{2}}

\end{itemize}

\subsection{Schnitt \Interval{1} \&\& \Interval{2} : Intervall}
\begin{itemize}
\item \before{\Interval{1} \&\& \Interval{2}} <=> (((\before{\Interval{1}} \&\& \aktiv{\Interval{2}}) ||
(\before{\Interval{2}} \&\& \aktiv{\Interval{1}}) || (\before{\Interval{1}} \&\& \before{\Interval{2}}))
\textbackslash (\after{\Interval{1}} || \after{\Interval{2}}))
\item \after{\Interval{1} \&\& \Interval{2}} <=> \after{\Interval{1}} ||
\after{\Interval{2}}
\item \aktiv{\Interval{1} \&\& \Interval{2}} <=> \aktiv{\Interval{1}} \&\& \aktiv{\Interval{2}}
\end{itemize}

\subsection{Differenz \Interval{1} \textbackslash\ \Interval{2} : Interval}
Alle Zeitpunkte, die in \Interval{1} liegen, nicht aber in \Interval{2}:
\begin{itemize}
  \item  \Interval{1} \textbackslash\ \Interval{2} <=> \Interval{1} \&\&
  \comp{\Interval{2}}
\end{itemize}


\subsection{within(e,\Interval{}) : Event}
within(e,\Interval{}) <=> (e \&\& \aktiv{\Interval}) || (e \&\& \before{\Interval})

\subsection{not\_within(e,\Interval{}) : Event}
not\_within(e,\Interval{}) <=> (e \&\& ! \aktiv{\Interval}) \textbackslash\ \before{\Interval}

\subsection{ StrictlyWithin(e,\Interval{}) : Event}
StrictlyWithin(\Interval{},e) <=> (e \&\& \aktiv{\Interval}) \textbackslash\ \after{\Interval}

\subsection{ not\_strictlyWithin(e,\Interval{}) : Event }
not\_strictlyWithin(e,\Interval{}) <=> (e \&\& ! \aktiv{\Interval}) || (e \&\& \after{\Interval})


\subsection{weitere Anmerkungen}
Der Umstand, dass sich \Interval{} und \comp{\Interval{}} zwei Zeitpunkte teilen, mag
unintuitiv erscheinen, allerdings  bietet dies nicht nur Nachteile. So ist \Interval{}
|| \comp{\Interval{}} wie  erwartet immer aktiv, beginnt und endet niemals. \Interval{}
\&\& \comp{\Interval{}} ist niemals aktiv  und l"ost auch niemals before oder
after Ereignisse aus.

  \section{An Events gebundene Werte}
Es ist m"oglich, beliebige Werte an Events zu binden. Diese M"oglichkeit
existiert auch f"ur Intervall-Events. Der Wert eines Intervalls entspricht dem Wert des Before-Events.

Auf den aktellen Wert des Intervalls wird "uber \val\Interval{}
zugegriffen. 

Nachfolgend wird das Standardverhalten der Intervall-Operatoren dargestellt.
Allerdings kann das Verhalten der Operatoren bei Bedarf abge"andert werden. Dafür muss mit der Funktion map ähnlich wie bei puntuellen Events der Wert transformiert werden.

\subsection{Intervall zwischen dem Event B und dem Event A)}
F"ur between-Intervalle wie in Abbildung \ref{interval-between_b_a} gilt der Wert des
Before-Events bis zum End-Event. Dannach hat das Intervall den Wert null. Der
Wert des After-Events wird allerdings nicht im Komplement gespeichert. Beim
Intervall\ref{interval-between_b_a} gilt also:
\[
val(t) = \begin{cases}
null & t < 1 \\
B.val & t >= 1 \; and \; t < 9 \\
null & t >= 9
\end{cases}
\]

\begin{figure}[h]
 \centering 
\psset{unit=1cm}
\begin{pspicture}(0,0)(10,2)
\psgrid[subgriddiv=1,griddots=10,gridlabels=7pt](0,0)(10,1)
%{
%	\pspolygon[fillcolor=greenyellow,fillstyle=solid,linestyle=none](0,0)(0,1)(1,1)(1,0)

	\rput(1.2,0.7){\psframebox*[framearc=.3]{B}}
	\rput(9.2,0.7){\psframebox*[framearc=.3]{A}}
	\psline[linewidth=1pt]{[-]}(1,0.5)(9,0.5)
%}
\end{pspicture}
\caption{Intervall-Event between(B,A)}
\label{interval-between_b_a}
\end{figure}
 
\subsection{Vereinigung von Intervallen}
Wie oben wird der Wert des \before{\_}-Events gespeichert. Dies ist in diesem Fall das Event, dass das Interval zuletzt
aktiviert hat.

\begin{figure}[h]
 \centering 
\psset{unit=1cm}
\begin{pspicture}(0,0)(10,4)
\psgrid[subgriddiv=1,griddots=10,gridlabels=7pt](0,0)(10,3)
%{
	\rput(1.2,2.75){\psframebox*[framearc=.3]{B}}
	\rput(7.2,2.75){\psframebox*[framearc=.3]{A}}
	\psline[linewidth=1pt]{[-]}(1,2.5)(7,2.5)
	
	\rput(3.2,1.75){\psframebox*[framearc=.3]{B'}}
	\rput(9.2,1.75){\psframebox*[framearc=.3]{A'}}
	\psline[linewidth=1pt]{[-]}(3,1.5)(9,1.5)
	
	\rput(1.2,0.75){\psframebox*[framearc=.3]{B}}
	\rput(9.2,0.75){\psframebox*[framearc=.3]{A'}}
	\psline[linewidth=1pt]{[-]}(1,0.5)(9,0.5)
%}
\end{pspicture}
\caption{Vereinigung zweier Intervall-Events: between(B,A) || between(B',A')}
\label{interval-or}
\end{figure}
  
F"ur das in Abb\ref{interval-or} zu sehende Interval\ref{interval-or}
between(A,B) || between(A',B') gilt also die folgende Belegung des Wertes:
\[
val(t) = \begin{cases}
null & t < 1 \\
B.val & t >=1 \; and\; t < 9 \\
null & t >= 9 \\
\end{cases}
\]
  
  \subsection{Schnittmenge zwischen Intervallen}
Bei der Schnittmenge zwischen zwei Intervall-Events werden die Event-Werte der
beiden aktiven Interval-Events zu einem Tupel zusammengefasst. 

\begin{figure}[h]
 \centering 
\psset{unit=1cm}
\begin{pspicture}(0,0)(10,4)
\psgrid[subgriddiv=1,griddots=10,gridlabels=7pt](0,0)(10,3)
%{
	\rput(1.2,2.75){\psframebox*[framearc=.3]{B}}
	\rput(7.2,2.75){\psframebox*[framearc=.3]{A}}
	\psline[linewidth=1pt]{[-]}(1,2.5)(7,2.5)
	
	\rput(3.2,1.75){\psframebox*[framearc=.3]{B'}}
	\rput(9.2,1.75){\psframebox*[framearc=.3]{A'}}
	\psline[linewidth=1pt]{[-]}(3,1.5)(9,1.5)
	
	\rput(3.2,0.75){\psframebox*[framearc=.3]{(B,B')}}
	\rput(7.2,0.75){\psframebox*[framearc=.3]{(A', A)}}
	\psline[linewidth=1pt]{[-]}(3,0.5)(7,0.5)
%}
\end{pspicture}
\caption{Schnittmenge zweier Intervall-Events: between(B,A) and
between(B',A')}
\label{interval-and}
\end{figure}

Wie in Abb. \ref{interval-and} zu sehen, ergibt sich das folgende Zeitliche
Verhalten f"ur den Wert von Interval\ref{interval-and} \[
val(t)=\begin{cases}
null & t < 3 \\
(B,B') & t >=3 \; and\; t < 7 \\
null & t >= 7
\end{cases}
\]

\subsection{Differenz zweier Intervall-Events}
Bei der Differenz zwischen zwei Intervall-Events ist der Wert des Intervalls
gleich dem Wert des letzten Before-Events vor oder nach dem Schnitt.

\begin{figure}[h]
 \centering 
\psset{unit=1cm}
\begin{pspicture}(0,0)(10,4)
\psgrid[subgriddiv=1,griddots=10,gridlabels=7pt](0,0)(10,3)
%{
	\rput(1.2,2.75){\psframebox*[framearc=.3]{B}}
	\rput(4.2,2.75){\psframebox*[framearc=.3]{A}}
	\psline[linewidth=1pt]{[-]}(1,2.5)(4,2.5)
	
	\rput(6.2,2.75){\psframebox*[framearc=.3]{B''}}
	\rput(9.2,2.75){\psframebox*[framearc=.3]{A''}}
	\psline[linewidth=1pt]{[-]}(6,2.5)(9,2.5)
	
	\rput(3.2,1.75){\psframebox*[framearc=.3]{B'}}
	\rput(5.2,1.75){\psframebox*[framearc=.3]{A'}}
	\psline[linewidth=1pt]{[-]}(3,1.5)(5,1.5)
	
	\rput(1.2,0.75){\psframebox*[framearc=.3]{B}}
	\rput(3.2,0.75){\psframebox*[framearc=.3]{B'}}
	\psline[linewidth=1pt]{[-]}(1,0.5)(3,0.5)
	
	\rput(6.2,0.75){\psframebox*[framearc=.3]{B''}}
	\rput(9.2,0.75){\psframebox*[framearc=.3]{A''}}
	\psline[linewidth=1pt]{[-]}(6,0.5)(9,0.5)
%}
\end{pspicture}
\caption{between(B,A) \textbackslash\ between(B',A')}
\label{interval-diff}
\end{figure}

F"ur Interval\ref{interval-diff} = between(B,A) \textbackslash\ between(B', A') ergibt
sich also folgende Belegung:
\[
val(t)=\begin{cases}
null & t < 1 \\
B & t \in [1,3] \\
null & t \in [3,6] \\
B'' & t\in[6,9]\\
null & t >9
\end{cases}
\]



Desweiteren sei zu den Werten gesagt, dass es bei within und strictlyWithin ebenfalls die Möglichkeit gibt, die Werte des punktuellen Events und des IntervalEvents zu verbinden. Dies ist aus Implementierungs-Sicht einem direkten Zugriff auf den Wert eines Intervalls innerhalb einer Event-Deklaration vorzuziehen, da der genaue Zeitpunkt des Wertwechsels nicht fest definiert ist, und deshalb an den Endpunkten des Intervalls die Werte, die \val{\Interval{}} zurückgibt, nicht verlässlich sind. Ausserhalb von Event-Deklarationen und angehängten Reaktionen kann allerdings gefahrlos darauf zugregriffen werden. Zu jedem Zeitpunkt, zu dem \aktiv{\Interval{}} korrekte Rückgaben macht, tut \val{\Interval{}} dies ebenfalls.

Für verlässliche Werte von active und value sind die beiden Funktionen isActive und value zu verwenden, innerhalb des Event-Dispatchings greifen diese auf pull-basierte Techniken zurück, um verlässliche Werte zu generieren. Da die Verwendung dieser Funktionen meist unnötig ist, und die push-basierten Operatoren performancemäßig überlegen sind, sollte wo möglich darauf verzichtet werden.

\include{implementation}
\include{examples}

\section{Resümee}
Durch die Verwendung von Intervall-Events kann man zustandsbasierte
Probleme deklarativ lösen. Man spart sich dann die imperative Implementierung
eines Zustandsautomaten. Dies verbessert die Verständlichkeit des Quellcodes und
verringert somit die Wartungskosten für ein Software-Projekt. 

Allerdings bringt die Verwendung von Intervall-Events auch Probleme mit sich.
Die Deregistrierung von Events obliegt nämlich dem Benutzer. Wenn ein Benutzer
nicht länger benötigte Events nicht wieder vom Event-Graph abkoppelt, dann
können die zu den Events gehörenden Objekte nicht freigegeben werden. Dies hat
zur Folge, dass der Speicherverbrauch der Anwendung möglicherweise immer weiter
ansteigt. 

Die Intervall-Events können nicht automatisch deregistriert werden, da nicht
bekannt ist, ob der Benutzer noch Interesse am Intervall-Event hat. Es könnte
sein, dass ein Intervall-Event nur ein einziges mal für den Benutzer von
Interesse ist. Möglicherweise benötigt der Benutzer das Intervall-Event aber
mehrfach. Wichtig ist daher, dem Benutzer die Deregistrierung der Events
nahezulegen.

\section{Ausblick}
Der nachfolgende Ausblick betrifft Events im Allgemeinen und Intervall-Events im
speziellen.

Zukünftig sollte sich die Intervall-Events-Library in zwei Richtungen
weiterentwickeln. Zum einen ist es wichtig den Benutzer bei der Deregistrierung
von nicht mehr benötigten Intervall-Events zu unterstützen. Und zum anderen kann
die Intervall-Events-Library ihr volles Potential nur ausspielen, wenn
die Implementierung effizient in Multithreading-Szenarien funktioniert.

\subsection{Konzepte zur Vereinfachung der Deregistrierung von Reactions}

Möglicherweise könnte man eine Datenfluss-Analyse im Kontrollfluss-Graph
vornehmen, um nach Events zu suchen. Wenn ein Event gefunden wurde, auf den eine Reaction
registriert wurden, muss sichergestellt werden, dass auch eine Reaction wieder
entfernt wird. Allerdings ist das ein "`Best-Efford"'-Ansatz. Man kann auf diese
Weise nicht in allen Fällen sicherstellen, dass die verwendeten Events immer
korrekt aufgeräumt werden.

Außerdem könnte man dem Benutzer Zugriff auf den Funktionszeiger von
anonymen Funktionen bereitstllen. Wenn Intervall-Events in Methoden verwendet
werden, sind diese Intevalle dann meist nur selten aktiv und müssen nach 
zeitlich kurzer Zeit wieder deregistriert werden. Allerdings sollten dabei 
keine anonymen Funktionen verwendet werden. Anonyme Funktionen können nämlich 
nicht deregistriert werden, da keine Möglichkeit besteht, an den Funktionszeiger
der anonymen Funktion zu kommen, um diese wieder zu deregistrieren.

\subsection{Effiziente und skalierbare Funktionsweise in
Multithreading-Szenarien}
Die Threadsicherheit ist eine überaus wünschenswerte Eigenschaft für
Intervall-Events. In der Zukunft werden Interaktionen zwischen verschiedenen 
Thread zunehmend immer wichtiger. Das Konzept der Events und der
Intervall-Events ist natürlich nicht auf sequenzielle Prozesse beschränkt und
skaliert sehr gut auch auf Thread- und Prozess-Ebene. Diese Tatsache
manifestiert sich in der Existenz von Messageoriented
Middleware. 

Um die Intervall-Events-Implementierung Multithreading-sicher zu machen, muss
geprüft werden, ob alle Zustandsänderungen des Aktiv-Zustands eines
Intervall-Events multithreading-sicher sind. Weiterhin muss die Events-Library
Multithreading-sicher sein.

\listoffigures\addcontentsline{toc}{section}{\listfigurename}
\end{document}
