\section{Implementierung}

Die Implementierung der Interval-Events hat das gleiche Schema wie die
Implementierung der Events. Es handelt sich bei Intevall-Events um eine
spezielle Form von Event-Nodes die aus einem Start- und einem Stop-Event
bestehen.

Wie bei jedem Event-Node aus dem scala.events-Package durchläuft ein
Intervall-Event einen Lebenszyklus bestehend aus dem Setup des Event-Graphen,
der Registrierung von Reactions, dem Deploy, der Unregistrierung von Reactions
und dem Undeploy von Event-Nodes. Dieser Lebenszyklus ist auch in
Abb. \ref{event_node_lifecycle} zu sehen.

%\usepackage{graphics} is needed for \includegraphics
\begin{figure}[htp]
\begin{center}
  \includegraphics[width=0.7\textwidth]{graphics/EventNode-Lifecycle}
  \caption{Lifecycle eines EventNodes}
  \label{event_node_lifecycle}
\end{center}
\end{figure}


Es gibt, wie in Abb.\ref{interval_events_structure} zwei Klassen von
Interval-Event-Nodes: BetweenEvents und ExecutionEvents. BetweenEvents sind vom
Auftreten des StartEvents bis zum Auftreten des ersten End-Events aktiv, wenn
eine Reaction registiert wurde. Das Execution-Event dient dazu, die Ausführung
einer Funktion zu protokollieren. Wenn das Execution-Event eine Funktion
überwachen soll, dann instrumentiert der Compiler die Funktion so, dass ein
Before-Event beim Betreten der Funktion und ein After-Event beim Verlassen der
Funktion ausgelöst wird.

%\usepackage{graphics} is needed for \includegraphics
\begin{figure}[htp]
\begin{center}
  \includegraphics[width=0.5\textwidth]{graphics/interval_event_structure}
  \caption{Arten von Intervall-Events}
  \label{interval_events_structure}
\end{center}
\end{figure}


\subsection{Der Aufbau des Event-Graphen}
Mithilfe von Event-Nodes können mehrere Events zu komplexeren Events
zusammengefasst werden. So ist es beispielsweise möglich, alle Events einer
Filter-Bedingung zu unterziehen. Das resultierende Event wird nur dann
ausgelöst, wenn ein zu filterndes Event auftritt dessen Filterbedingung zu true
auswertet. 

Der daraus resultierende Abhänigkeitsgraph soll nachfolgend als Event-Graph
bezeichnet werden.

Intervall-Events können uneingeschränkt auch als Knoten im Event-Graph
vorkommen. Eine Liste der möglichen Filterfunktionen und die dazugehörigen
Definitionen findet sich im Kapitel \ref{definitions}.

\subsection{Auswertung des Event-Graphen}

Bei der Auswertung eines Event-Graphen gibt es zwei möglichen Vorgehensweisen.
Zum einen kann Events sammeln, die bei Event-Graphen ankommen und dann
weiterleiten, wenn gewisse Bedingungen erfüllt sind. Hierbei handelt es sich um
eine Push-basierte Implementierungen. Es werden nämlich nur Änderungen gepusht.

Beim Zweiten Ansatz werden keien Ändeurngen weitergeleitet. Stattdessen wird der
Event-Graph traversiert um herauszufinden, ob Änderungen passiert sind. Dieser
Ansatz wird nachfolgend als pull-Basiert bezeichnet.

Bei gleichem Resultat haben beide Implementierungen verschiedene Vor- und
Nachteile. Nateilig beim Push-Basierten Ansatz ist die relativ hohe Komplexität
der Implementierung wenn Knoten im Event-Graph einen Zustand aufweisen.
Außerdem ist es schwierig, ein deterministisches Verhalten sicherzustellen. Beim
Pull-basierten Ansatz stellt sich stattdessen die Frage, wie man den richtigen
Zeitpunkt für einen Pull ermitteln kann. 

Die Implementierung im scala.events-Modul verwendet einen hybriden Ansatz um den
Event-Graphen auszuwerten. Die meisten Event-Knoten wurden Push-Basiert
implementiert. Eine Ausnahme stellt der Except-Knoten dar. Mit einem
Event-Knoten können verschiedene Events ausgeschlossen werden. Der Except-Zweig
des Event-Knotens wurde pull-basiert implementiert.

Betrachten wir nachfolgend zwei Beispiele um diese Vorgehensweise zu begründen:
\begin{eqnarray}
val \; e & = e1 \setminus (e2 || e3)\\
val \; e & = e1 \setminus (e1 || e3)
\end{eqnarray}

Der Event-Graph des Push-basierten Ansatzes ist in
Abb.\ref{push_based_event_graph} zu sehen. Wenn das Event e1 ausgelöst wird,
startet zunächst das Sammeln von Reactions im Knoten e1 und folgt den im
Diagramm eingezeichneten Kanten. 

Der Except-Event-Knoten speichert intern ob bereits ein Sammelvorgang über den
Except-Zweig durchgeführt wurde. Ist dies nicht der Fall, dann wird das Sammeln
in e forgesetzt und die Reaction auf das Event e wird gesammelt. 

Wenn allerdings schon eine Sammlung über den Except-Zweig erfolgte, dann
verhindert der Except-Knoten das Sammeln der Reactions von e.

Der in Abb.\ref{pull_based_event_graph} beschriebene Ansatz funktioniert
prinzipiell genauso. Allerdings wird im Except-Event-Node explizit der Pull-Vorgang ausgelöst um zu
prüfen, ob die Except-Bedingung gilt oder nicht. Der Except-Knoten speichert
dann keinen internen Zustand mehr.

Betrachten wir nun das Beispiel zwei. Das Beispiel 2 ist praktisch von keiner
Bedeutung. Allerdings zeigt es gut die Einschränkungen einer Push-Basierten
Implementierung auf. 

Wenn der Event e1 ausgelöst wird, kann das Sammeln von Reactions nun mit zwei
Knoten starten. Entweder werden zunächst über den Or-Knoten die Reactions vom
Except-Knoten gesammelt. Dann schaltet der Except-Knoten seinen internen Zustand
um. Wenn anschließend die Sammlung über die zweite Kante von e1 erfolgt, hat
sich der Zustand von Except bereits geändert, sodass keine Reaktionen von e
gesammelt werden.

Wenn allerdings zunächst der Except-Knoten besucht wird, hat dieser seinen
internen Zustand noch nicht umgeschaltet. Dann werden die Reactions von e
gesammelt. Erst wenn später der Except-Knoten über den Or-Knoten besucht wird,
schaltet der Except-Knoten seinen Zustand um. Allerdings wurde dann schon die
Reaction von e gesammelt. Daher wird nach dem Sammeln der Reactions
fälschlicher Weise der Event e ausgelöst.


 


%\usepackage{graphics} is needed for \includegraphics
\begin{figure}[htp]
\centering
\subfigure[Push basierter Event-Gaph] {
  \includegraphics[width=0.3\textwidth]{graphics/event_node_except_push}
  \label{push_based_event_graph}
}
\subfigure[Push/Pull basierter Event-Graph] {
  \includegraphics[width=0.3\textwidth]{graphics/event_node_except_pull}
  \label{pull_based_event_graph}
}
\caption{Event-Graphen für das Beispiel 1}
\end{figure}

\begin{figure}[htp]
\centering
\subfigure[Push basierter Event-Gaph] {
  \includegraphics[width=0.3\textwidth]{graphics/event_node_except2_push}
  \label{failing_push_based_event_graph}
}
\subfigure[Push/Pull basierter Event-Graph] {
  \includegraphics[width=0.3\textwidth]{graphics/event_node_except2_pull}
  \label{working_pull_based_event_graph}
}
\caption{Event-Graphen für das Beispiel 2}
\end{figure}


\subsubsection{Einschränkungen der Implementierung}
In einem Event-Graph können nicht EventNodeRef oder EventNodeExists in einem
Pfad zusammen mit EventNodeExcept verwendet werden, da dies möglicherweise zu
nicht korrekten Ergebnissen führen würde.

Beim EventNodeExcept kann ein Except-Event empfangen werden, der das Entfernen
von Reactions auslöst. Die sorgt möglicherweise für Inkonsistenzen
bei Vorgängerknoten im Event-Graphen, wenn sich die Reaction des Except-Knotens
vor der Reaction eines anderen Knotens in der ReactionListe befindet.
Daher muss im Falle eines Except-Events immer ein Undeploy und ein Deploy
ausgeführt  werden, um die geänderten Reactions weiterzupropagieren.

Dies funktioniert allerdings nicht mehr länger mit EventNodeRef oder
EventNodeExists, dieses die Reihenfolge von Reactions verändern können.
